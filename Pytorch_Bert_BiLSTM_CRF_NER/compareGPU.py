# -*- coding: utf-8 -*-
from transformers import BertModel, BertTokenizer
import torch
# from list import *
import numpy as np
from itertools import combinations

# 检查CUDA是否可用，并据此设置设备
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"Using device: {device}")

# ====================================================================================
# 初始化BERT中文模型和分词器，并将模型移动到指定的设备上
tokenizer = BertTokenizer.from_pretrained('../huggingface/bert-base-chinese')
model = BertModel.from_pretrained('../huggingface/bert-base-chinese').to(device)
# 假设的实体列表
extracted_entities = [
'紧固件松动',
'水位问题',
'尾水流速过大',
'能量消耗器故障',
'生物附着',
'积垢',
'井内淤泥和沉积物',
'调速系统问题',
'防水问题',
'导致水流分布不均',
'润滑脂干涸',
'相序故障',
'性能异常或损坏',
'导叶立面密封未压紧',
'蜗壳内的高压水流冲击转轮',
'未能准确响应',
'发电机故障',
'水轮机导水机构故障',
'性能下降',
'中轴套漏水量大于顶盖排水泵和自流排水总排水量',
'滚动元件磨损',
'井盖问题',
'埋件固定不牢固',
'刻度不准确',
'机械部件损坏',
'下沉',
'电压不稳定或过高/过低',
'不适当调整',
'结构损伤',
'轴领磨损',
'电线短路',
'漏水',
'泄漏',
'支持结构的变形',
'密封不良',
'短路',
'电流急剧上升',
'外缘变得凹凸不平',
'裂缝',
'异常振动',
'保压不足的',
'筒体与轴承座之间的不正确配合',
'密封部件变形',
'故障',
'超负荷运行',
'过载',
'联轴器内部的摩擦和磨损增加',
'拒动作',
'交通堵塞和安全风险',
'颜色变化',
'调压室防冲刷结构破坏',
'内部润滑油道堵塞',
'水轮机振动',
'排水问题',
'渗漏',
'松动',
'通道堵塞',
'内壁磨损不均',
'性能问题',
'电气系统故障',
'筒形阀故障',
'堵塞',
'地基沉降',
'空化',
'表面出现裂纹',
'接力器操作力矩变大',
'固定导叶的脱流现象',
'蜗壳漏水',
'橡胶与金属之间的粘接不良',
'门闸卡滞或无法关闭',
'机械故障',
'轴承故障',
'导叶漏水量增大',
'负荷波动故障',
'物理损坏',
'疲劳损伤',
'水体泄漏和土壤侵蚀',
'顶盖平压管漏水',
'无法正常工作',
'过热问题',
'橡胶层脱落',
'腐蚀',
'油封泄漏',
'水尺变形或不规则',
'导叶封水不严',
'冷却系统故障',
'温度升高',
'安装误差',
'活动导叶与轴套配合间隙过小',
'活动导叶拒动作',
'内壁积垢',
'侵蚀',
'断裂',
'压板下沉或上翘',
'结构性损坏',
'缺陷',
'设备无法正常运行',
'电气系统短路',
'导叶在剪断销断开后出现旋转',
'材料脆化',
'老化',
'电气控制系统故障',
'损坏',
'磨损',
'卡阻',
'密封材料的老化',
'润滑油循环不畅',
'轴领与轴承座之间的配合不良',
'绝缘故障',
'水流涡旋过大',
'密封效果不佳',
'排水效果下降',
'机械损坏或磨损',
'启闭机械故障',
'排水泵电动机本身的故障',
'结构失稳',
'油脂泄漏',
'密封故障',
'支撑结构变形',
'振动磨损',
'消防设备故障',
'安全设施故障',
'照明故障',
'出现故障',
'闸门故障',
'漆层剥落',
'振动或不平衡',
'裂纹',
'分块瓦磨损不均',
'滚轮的润滑不够',
'发电机失励',
'热膨胀而失效',
'传感器输出信号异常',
'金属结构腐蚀',
'润滑管道堵塞',
'密封件老化',
'导叶拒动作故障',
'内部密封性能下降',
'保持架断裂',
'受损',
'温度异常',
'控制系统故障',
'通道和平台损坏',
'叶轮损伤',
'压力异常',
'结构损坏',
'分块瓦的固定螺栓松动',
'金属疲劳',
'漏水或密封失效',
'污染和覆盖物',
'冻结',
'闸门底部或基础出现沉降',
'内部元件的磨损',
'外环开裂',
'润滑油质量下降',
'失效',
'密封不严',
'橡胶元件老化',
'润滑油道堵塞',
'油泵故障',
'燃油系统故障',
'沉砂池问题',
'沉积物堆积',
'电动机无法正常工作',
'机组的稳定性比较差',
'控制机构设计缺陷',
'内圈断裂',
'积水',
'润滑油劣化',
'相关设备故障',
'工作密封本体故障',
'螺栓松动',
'存在较多的滚轮损坏',
'积水和水体溢出',
'频率不稳定',
'堰坝结构问题',
'操作拒动作',
'排水不正常',
'漏油',
'翼型空化',
'转速不稳定',
'负荷调节不灵活',
'侵蚀问题',
'振动增大',
'输出电压波形不正常',
'顶盖泵的低效率',
'漏水量偏大',
'导叶端面密封易磨损及空蚀',
'振动',
'立面密封缺陷',
'电气故障',
'顶盖排水系统缺陷',
'油位波动过大',
'轴承振动过大',
'功能故障',
'结构连接不稳定',
'拒动作故障',
'前后压差过大',
'输出电压波动',
'不符合设定值',
'失速',
'井壁的破裂',
'井底的破损',
'密封损坏',
'前端与后端发生偏差',
'过度磨损',
'调压闸门故障',
'空蚀',
'破损',
'润滑油温度过高',
'空腔空化',
'剪断',
'渗油',
'顶盖排水系统排水不正常',
'划痕或磨损',
'噪音增加',
'廊道排水系统失效',
'冻结和爆裂',
'结构受损',
'水流效率下降',
'卡滞',
'损伤',
'润滑不良',
'电缆故障',
'开关失灵',
'发卡',
'剪断销断裂',
'水渗漏',
'降低效率',
'局部空化',
'泄流孔堵塞',
'水流涡流过大',
'振动增加',
'异常噪音',
'变形',
'润滑油流量不足',
'流量减小',
'压力升高',
'水头下降',
'油雾量异常增大',
'油温监测装置失效',
'退化',
'前后水头差别较大',
'机组性能下降',
'井体变形',
'可见裂缝',
'润滑油管路堵塞',
'水导轴瓦温度异常升高',
'油渍',
'润滑油减少',
'轴线不稳定',
'润滑油发泡',
'向下移动',
'发电机噪音异常',
'电流异常',
'电压不稳定',
'多个导叶同时拒动作',
'多个水轮机保护装置同时断裂',
'折断',
'异常声响',
'发卡漏水',
'轴承温度不均匀',
'连接处漏水',
'传感器问题',
'控制器故障',
'通信故障',
'润滑油变色',
'自励失效',
'开启缓慢或拒动作现象',
'荷波动故障',
'运行阻力突然增大',
'异物堵塞',
'整体拒动作',
'出现异常声音',
'震动',
'无法启闭',
'异响',
'防冲刷结构破坏',
'电刷磨损',
'绕组短路',
'断路',
'安装圆柱销时径向孔对密封可能造成损伤',
'润滑油循环系统出现故障',
'支持盖振动异常',
'法启闭',
'廊道结构下沉',
'空蚀振动',
'空蚀破坏',
'座环与顶盖之间密封漏水',
'导叶轴套密封漏水',
'顶盖与主轴密封之间密封漏水',
'严重损害',
'空化和空蚀',
'埋件损坏',
'材料性能下降',
'影响',
'润滑油油位异常降低',
'噪音增大',
'尾水流量或压力超出设计范围',
'无法准确控制水流',
'发出不寻常的响声',
'输出电压下降或消失',
'叶片空蚀',
'卡涩现象',
'上、下端面间隙过大',
'异常磨损',
'单个导叶拒动作',
'导叶整体拒动作',
'冷却系统效率下降',
'内部损伤',
'避免出现疲劳晰断裂',
'开启拒动作',
'润滑油中混入金属碎片',
'效率下降',
'轮毂或叶片损坏',
'空化和空蚀现',
'生锈或腐蚀',
'发现裂纹',
'表面腐蚀',
'井体变薄',
'单个导叶卡塞',
'润滑油压力不稳定',
'在开启状态时无法完全关闭',
'闸门关闭时有水流通过',
'垂直振动增大',
'垂直振动异常',
'生锈',
'受到额外的应力',
'局部过热',
'水导轴瓦温度异常',
'动作缓慢甚至拒动作',
'结构变形',
'焊接裂纹',
'发生位移',
'变形或损坏',
'停机',
'失去燃油供应',
'沉砂效果减弱',
'尾水中悬浮物',
'泥沙含量升高',
'水渍',
'湿斑',
'错误校准',
'异常',
'润滑油出现污染',
'油压不足',
'调速系统接力器缸径偏小',
'设计余量不足',
'闸门冻结',
'顶盖泵效率低',
'止回阀损坏',
'密封块磨损',
'浮动环卡阻',
'检测仪器故障',
'主拐臂与上轴套接触表面磨损',
'两侧密封接触面被破坏',
'沉积物积聚',
'输出电压频率波动',
'间隙过大'
]
def encode_texts(texts):
    # 对一批文本进行编码
    encoded_batch = tokenizer(texts, padding=True, truncation=True, return_tensors="pt", max_length=512)
    return encoded_batch["input_ids"].to(device), encoded_batch["attention_mask"].to(device)

def get_bert_embeddings(texts):
    # 获取一批文本的嵌入
    input_ids, attention_mask = encode_texts(texts)
    with torch.no_grad():
        outputs = model(input_ids, attention_mask=attention_mask)
    embeddings = outputs.last_hidden_state[:, 0, :]  # 获取[CLS]标记的嵌入
    return embeddings

# 现在，我们可以传入一个文本列表到`get_bert_embeddings`并获得它们的嵌入
embeddings = get_bert_embeddings(extracted_entities)

# 接下来的部分可以进行相似度计算，不需要改变索引方式


def cosine_similarity(vec1, vec2):
    return torch.nn.functional.cosine_similarity(vec1, vec2).item()

def jaccard_similarity(str1, str2):
    set1 = set(str1)
    set2 = set(str2)
    intersection = set1.intersection(set2)
    union = set1.union(set2)
    return len(intersection) / len(union)

# 定义alpha值
alpha = 0.7

# 为每对实体计算加权相似度
weighted_similarities = {}


# 打印嵌入张量的形状以确认其大小
print("Embeddings tensor shape:", embeddings.shape)

# ===================================================================================================================

for i, entity1 in enumerate(extracted_entities):
    for j, entity2 in enumerate(extracted_entities):
        if i < j:  # 避免重复计算和自比较
#             print(f"Accessing embeddings[{i}] and embeddings[{j}]")  # 打印当前索引
            vec1 = embeddings[i]  # 直接使用索引i和j获取嵌入
            vec2 = embeddings[j]
            # 以下是余下的计算相似度和处理逻辑...
            jac_sim = jaccard_similarity(entity1, entity2)
            sem_sim = cosine_similarity(vec1.unsqueeze(0), vec2.unsqueeze(0))
            weighted_sim = alpha * jac_sim + (1 - alpha) * sem_sim
            weighted_similarities[(entity1, entity2)] = weighted_sim

# 确定相似度阈值
threshold = 0.7
aligned_entities = {pair: sim for pair, sim in weighted_similarities.items() if sim > threshold}

# print(aligned_entities)
# 输出符合阈值条件的实体对及其相似度
for (entity1, entity2), similarity in aligned_entities.items():
    print(f"({entity1}, {entity2}): {similarity:.2f}")
